package scenarios;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

import uansim.DBR;
import uansim.DPR;
import uansim.Flood;
import uansim.Physical;
import uansim.DPR.NodeLayer;
import uansim.Application;
import uansim.Channel;
import uansim.Scheduler;
import utils.Geometry;
import uansim.Node;

public class Scenario3 {

	double m_NetworkDensity=1;
	int m_numAttackers=0;		//(0 or 1)
	double m_boundary=1500;		//(m) extent of deployment area
	double m_depth=100;			//(m) maximum node depth
	long topologySeed=34341;	
	int numberOfMessages=100;	//(messages) generated by the source
	double generationRate=100;	//(byte per second)
	int messageLength=100;		//(bytes)
	boolean debug=false;
	double COMMUNICATION_RANGE=150;	// (m)

	public void run() {

		Channel channel=new Channel();
		Physical physical = new Physical(channel);
		DPR dbr = new DPR(physical);
		Physical.setFramingBitOverhead(32);		// (per frame)
		Flood.MAX_TTL=5;
		Physical.BIT_RATE=30000/8;			// (byte per second)
		DBR.MAXIMUM_FORWARDING_DELAY=100;	//
		DBR.FORWARDING_THRESHOLD=0;
		Arrays.fill(DPR.FORWARDING_PROBABILITY,0.0);
		
		int nodeCount=(int) Math.ceil((m_NetworkDensity) * m_boundary * m_boundary  * m_depth /
                (4/3 * Math.PI * Math.pow(COMMUNICATION_RANGE,3)));
		
		log("Number of underwater nodes = " + nodeCount);
		

		//#ifdef UAN_PROP_BH_INSTALLED
		//Ptr<UanPropModelBh> prop = CreateObjectWithAttributes<UanPropModelBh> ("ConfigFile", StringValue ("exbhconfig.cfg"));
		//#else 
		//Ptr<UanPropModelIdeal> prop = CreateObjectWithAttributes<UanPropModelIdeal> ("CommunicationRange", DoubleValue(m_commRange));
		//#endif //UAN_PROP_BH_INSTALLED
		//Ptr<UanChannel> channel = CreateObjectWithAttributes<UanChannel> ("PropagationModel", PointerValue (prop));


		Random rand = new Random(topologySeed); 
		Vector sinkPos = new Vector(m_boundary/2.0, m_boundary/2.0, 0);
		ArrayList<Vector> nodePositions = generateTopology(sinkPos, nodeCount, rand);

		int sourceNode = chooseSource(nodePositions);		
		log("Selected node #" + sourceNode + " as source.");
		
		//Choose the attacker node location to affect as many neighbors of the source node as possible
		Vector attackerPos = placeAttacker(sourceNode, nodePositions);
		log("Placed attacker at " + attackerPos.x() + "\t" + attackerPos.y() + "\t" +attackerPos.z());
		
		//Count source node neighbors
		int sourceNeighborsCount = countSourceNeighbors(sourceNode, nodePositions);
		log("Number of neighbors of source nodes = " + sourceNeighborsCount);


		//Create nodes
		NodeLayer sink = dbr.new NodeLayer(new Node(sinkPos.pos));
		
		NodeLayer[] nodes = new NodeLayer[nodeCount];
		
		for(int i=1; i<nodePositions.size(); i++) {
			Vector v = nodePositions.get(i);
			nodes[i-1] = dbr.new NodeLayer(new Node(v.pos));
		}
		NodeLayer source = nodes[sourceNode-1];
		
		if(m_numAttackers>0) {
			DPR.AttackNodeLayer attacker = dbr.new AttackNodeLayer(new Node(attackerPos.pos));
		}
		
		Application app = new Application(0, source, sink, 0.25, 12345)
				.setNumberOfMessages(numberOfMessages)
				.setGenerationBitRate(generationRate)
				.setMessageBitLength(messageLength); 
		

		if(debug) {
			Scheduler.it.enableDebug();
			dbr.enableDebug();
		}

		Scheduler.it.handleAll();

		if(debug) {
			physical.printStatistics();
			app.printStatistics();
		}
		
		int forwardedCount = 0;
		for(int i=0; i<nodes.length; i++) {
			if(i!=sourceNode)
				forwardedCount += nodes[i].getPhysical().statistics.sentCount;
		}


		log("total packets sent by source = " + source.getPhysical().statistics.sentCount);
		log("total packets received = " + app.receivedCount);
		log("total packets forwarded = " + forwardedCount);

		System.out.println("p\tattacks\tnodes\tdegree\tgenrtd\tsent\trecved\tforwd");
		System.out.println(DPR.FORWARDING_PROBABILITY[0] + "\t" + m_numAttackers + "\t" +
				nodeCount + "\t" + sourceNeighborsCount + "\t" + app.generatedCount + 
				"\t" + source.getPhysical().statistics.sentCount+"\t" + app.receivedCount + "\t" + forwardedCount);
		
	}

	private int countSourceNeighbors(int sourceNode, ArrayList<Vector> nodePositions) {
		Vector sourcePos = nodePositions.get(sourceNode);

		//Verify the network density by calculating the number of forwarders within the communication
		//range of the source node
		ArrayList<Integer> sourceNeighbors=new ArrayList<Integer>();
		for(int i=0; i<nodePositions.size(); i++) {
			boolean neighbor=false, vulnerable=false; 
			Vector nodePos = nodePositions.get(i);
			if(i!=sourceNode){
				if(nodePos.distanceTo(sourcePos) <= COMMUNICATION_RANGE) {
					sourceNeighbors.add(i);
					neighbor = true;
				}
			}
		}
		return sourceNeighbors.size();
	}

	private Vector placeAttacker(int sourceNode, ArrayList<Vector> nodePositions) {
		Vector sourcePos = nodePositions.get(sourceNode);
		Vector attackerPos = new Vector(sourcePos.x(), sourcePos.y(), sourcePos.z() +1.0);

		//Verify that the attacker can reach all neighbors of source but reaches no other nodes
		ArrayList<Integer> vulnerableNeighbors=new ArrayList<Integer>();
		for(int i=0; i<nodePositions.size(); i++) {
			boolean neighbor=false, vulnerable=false; 
			Vector nodePos = nodePositions.get(i);
			if(i!=sourceNode){
				if(nodePos.distanceTo(sourcePos) <= COMMUNICATION_RANGE) {
					neighbor = true;
				}
				if(nodePos.distanceTo(attackerPos) <= COMMUNICATION_RANGE) {
					 vulnerableNeighbors.add(i);
					 vulnerable = true;
				}
				if(neighbor!=vulnerable) {
					log("Failed to position attacker in an optimal location");
				}    
			}
		}
		return attackerPos;
	}

	private int chooseSource(ArrayList<Vector> nodePositions) {
		int sourceNode=-1;
		double maxDistance=0;
		Vector sinkPos = nodePositions.get(0);
		//Choose the furthest node from the sink to be the source
		for(int i=1; i<nodePositions.size(); i++) {
			Vector v = nodePositions.get(i);
			//pos->Add ( v );
		
			double distance = v.distanceTo(sinkPos);
			log("Node #" + (i) + " at\t" + v.x() + ", \t" + v.y() + ", \t" + v.z() + "  \td(sink) = " + distance);
			// Choose the node furthest from the sink to be source node
			// Should be out of the communication range of the sink
			if(distance>maxDistance) {
			   log("New max d(sink)");
			   maxDistance = distance;
			   sourceNode = i;
			 }
		}
		return sourceNode;
	}

	class Vector{
		double[] pos;
		public Vector(double x, double y, double z) {
			pos=new double[] {x, y, z};
		}
		public Vector(Random rand) {
			 pos=new double[]{rand.nextDouble()*m_boundary,
					 rand.nextDouble()*m_boundary,
					 rand.nextDouble()*m_depth};
		}
		
		double distanceTo(Vector v) {
			return Geometry.distance(pos, v.pos); 
		}
		
		double x() {return pos[0];}
		double y() {return pos[1];}
		double z() {return pos[2];}

	}

	private ArrayList<Vector> generateTopology(Vector sinkPos, int nodeCount, Random rand) {
		//Good nodes locations, including the sink
		ArrayList<Vector> connectedTopology;

		connectedTopology = new ArrayList<Vector>();
		connectedTopology.add(new Vector(m_boundary/2.0, m_boundary/2.0, 0.0));
		for(int i=0; i<nodeCount; i++) {
			Vector p;
			boolean isConnected;
			do {
				p = new Vector(rand);
				isConnected = false;
				for(int j=0; j<connectedTopology.size(); j++){
					Vector v = connectedTopology.get(j);
					double distance = p.distanceTo(v);
					if(distance <= COMMUNICATION_RANGE && p.z() > v.z()) {
						log("Node #" + (i+1) + " is connected to Node #" + (j));
						isConnected = true;
						break;
					}
				}
			} while(!isConnected);
			
			connectedTopology.add(p);
		}
		return connectedTopology;
	}
	
	private void log(String string) {
		if(debug)
			System.out.println("INFO:"+string);
	}

	public static void main(String[] args ) {
		new Scenario3().run();
	}
}
